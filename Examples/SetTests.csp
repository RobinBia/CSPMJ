-- SetTests

channel out,rem: Int

OutCard(S,i) = if empty(S) then out!-1 -> OutCard({i},i+1)
                else out!card(S) -> OutCard(union(S,{i}),i+1)
                 []  rem!i-1 -> OutCard(inter(S,{1..i-1}),i-1)
                
                

TestOutCard = OutCard({},1)

OutCard2(S,i) = if empty(S) then out!-1 -> OutCard({i},i+1)
                else out!i -> STOP


Test2 = OutCard2({3},4)
Test3 = OutCard2({},1)


csubset(x,y) = if union(x,y)==y then 1 else 0

Test4 = out!csubset({1},{1,2,3}) -> out!csubset({2},{3}) -> out!csubset({3,2},{2,3}) ->
        out!csubset({1..3},{1,3,4,2}) -> out!csubset({1..3},{1,2,4,2}) ->
        out!csubset({3,2,2},{2,3}) -> SKIP


ReplicationTest = [] x:{1,2,3} @ out!x -> rem!x -> SKIP
ReplicationTest2 = ||| x:{1,2,3} @ out!x -> rem!x -> SKIP
ReplicationTest3 = ; x:{1,2,3} @ out!x -> rem!x -> SKIP
ReplicationTest4 = |~| x:{1,2,3} @ out!x -> rem!x -> SKIP

Do(x) = x
ReplicationTest5 = Do([] x:{1,2,3} @ out!x -> rem!x -> SKIP)


ReplicationTest6C(z) = ||| x:{1,2,3} @ (let f(y) = z*y*x within
                                          rem?v:{1..3} -> out!f(v) -> SKIP)
ReplicationTest6 = ReplicationTest6C(2)


Segments = 5	-- the number of segments including the outside one
LastSeg = Segments - 1
TRACKS = {0..LastSeg}
REALTRACKS = {1..LastSeg}

datatype TRAINS = Thomas | Gordon

-- which can move between track segments

channel enter, leave : TRACKS.TRAINS

channel sensor_in, sensor_out

GateSeg = 2

Tracks = ||| j : REALTRACKS @ Track(j)

Track(j) = 
  let
    Empty   = enter.j?A -> (if j==1 then sensor_in -> Full(A) else Full(A))
    Full(A) = leave.j.A -> (if j==GateSeg then sensor_out -> Empty else Empty)
  within Empty

channel prime_enter: inter(TRACKS,{2,3,5,7}).TRAINS
TestEnumEnter = prime_enter?track?train -> leave!track!train -> TestEnumEnter


-- Test whether a let can be used inside a channel declaration
--channel testlet: let s = int(TRACKS,{2,4,6,8}) within union(s,{5}); is not allowed, Syntax error
--TestChLet = testlet!4 -> testlet?x -> testlet!x -> TestChLet


MAIN = ReplicationTest6 ; Tracks

TestDiff = [] x:diff({1,5,3},{2,1}) @ out!x -> SKIP


SetComp = { x*y | x<-{1,3,5} , y<-{1,2,4}}
SetComp2 = { x*y, x+y, x ,y | x<-{1,3,5} , y<-{1,2,4}}
SetComp3 = { x*y | x<-{1,3,5} , y<-{1,2,4}, x<y}


TestHideUnion1 = []x:{1,2,3,4,5} @ out!x -> SKIP \ union({out.1, out.2},{out.4})
S1 = {out.1, out.2}
S2 = {out.4}
TestHideUnion2 = []x:{1,2,3,4,5} @ out!x -> SKIP \ union(S1,S2)

-- Trace Check Generated by ProB:
PROB_TEST_TRACE = rem.2 -> out.4 -> rem.3 -> out.12 -> rem.3 -> out.18 -> enter.1.Gordon -> sensor_in -> leave.1.Gordon -> enter.2.Thomas -> enter.3.Gordon -> enter.4.Gordon -> enter.1.Thomas -> sensor_in -> leave.2.Thomas -> sensor_out -> leave.3.Gordon -> leave.4.Gordon -> STOP

assert MAIN [T= PROB_TEST_TRACE