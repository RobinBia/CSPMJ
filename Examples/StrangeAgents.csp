-- StrangeAgents


MyInt = {0..99}
channel ch: MyInt.MyInt
channel out,out2: MyInt

-- T(x) = ch!x?y:x>y -> out!y -> T(y) [] ch!x?y:x<=y -> out2!y -> T(y)
-- FDR says:  parse error, expecting `ARROW' near line 8 
-- cannot use CIA style boolean guards !
T(x) = ch!x?y:{z|z<-MyInt, z<x} -> out!y -> T(y) [] ch!x?y:{z|z<-MyInt, z>=x} -> out2!y -> T(y)

S(x) = ch?y!x -> S(y)

T1 = T(1)
S2 = S(2)


wire(P,A,Q) = (P [| A |] Q) \ A

wire1(A) = (T(1) [| A |] S(2)) \ A
wire1nh(A) = (T(1) [| A |] S(2))

TestWire0 = wire1({| ch |})

TestWire =
  wire(T(1), {| ch |}, S(2))
  
channel aout: {0..2}

negate(p)   = if p==0 then 1 else 0

negate2(1) = 0
negate2(0) = 1
negate2(2) = 0

AltBit(B) = SKIP [] aout!B -> AltBit(negate(B))  {- the state space is now finite with ProB -}
AltB = AltBit(2)

AltBit2(B) = SKIP [] aout!B -> AltBit2(negate2(B))  {- the state space is now finite with ProB -}
AltB2 = AltBit2(2)

Weird(W) = aout!1 -> W [] aout!2 -> Weird((W|||W))

Weird1 = Weird(W2)
channel a,b
W2 = a -> b -> SKIP

MyBoolVal = true
MyBoolConj(aa,bb) = aa or bb

TestMyBoolVal = if MyBoolVal then aout!1 ->SKIP else aout!2 ->SKIP
TestMyBoolConj = if MyBoolConj(false,MyBoolVal) then aout!1 ->SKIP else aout!2 ->SKIP  {- not accepted by ProBe but by FDR and us -}
TestMyBoolConj2 = if MyBoolConj(false,not(MyBoolVal)) then aout!1 ->SKIP else aout!2 ->SKIP


MAIN =  TestMyBoolVal ; TestMyBoolConj ; TestMyBoolConj2 ; AltB ; Weird1; TestiiW2 ; TestWire


do(x) = x

TestW2 = do(W2) {- not yet recognised as definite CSP process; but animation works -}
TestW2W2 = do(W2) ||| TestW2
TestifW2(x,y) = if true then x else y 
TestiW2 = TestifW2(do(W2),STOP) {- not yet recognised as definite CSP process; but animation works -}
TestiiW2 = TestiW2 ; TestiW2

-- Trace Check Generated by ProB:  (Check does not seem to terminate with FDR !!)
PROB_TEST_TRACE = aout.1 -> aout.1 -> aout.2 -> aout.2 -> aout.0 -> aout.1 -> aout.0 -> aout.1 -> aout.0 -> aout.2 -> aout.2 -> aout.1 -> a -> a -> a -> b -> b -> b -> a -> b -> a -> b -> a -> b -> out2.2 -> out.1 -> out2.2 -> out.1 -> out2.2 -> STOP

assert MAIN [T= PROB_TEST_TRACE

