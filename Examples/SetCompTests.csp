-- SetCompTests

channel out,rem: Int



MAIN = TestDiff ; TestSC ; TestSC2 ; TestSC3 ; TestSC4

TestDiff = [] x:diff({1,5,3},{2,1}) @ out!x -> SKIP


SetComp = { x*y | x<-{1,3,5} , y<-{1,4}}
SetComp2 = { x*y, x+y, x ,y | x<-{3,5} , y<-{2,4}}
SetComp3 = { x*y | x<-{1,3,5} , y<-{2,4}, x<y}

TestSC = out?x:SetComp -> SKIP
TestSC2 = ||| xx:SetComp @ out!xx -> SKIP
TestSC3 = ||| xx:SetComp2 @ out!xx -> SKIP
TestSC4 = ||| xx:SetComp3 @ out!xx -> SKIP

MySeq = {1,2,3,4}
TestSCard = out!card(MySeq) -> SKIP

channel outf:{0..9}

SetOutf = {outf.0, outf.1, outf.2, outf.9}

TestDSC = outf?x -> STOP [| diff( {|outf|}, {outf.8} ) |] STOP -- Ok, FDR finds outf.8
-- TestDSCb = outf?x -> STOP [| diff( {|outf|}, SetOutf ) |] STOP 
TestDSC2 = out?x -> STOP [| diff( {|out|}, {out.8} ) |] STOP  -- FDR says card infinite

channel outf2:{0..99}.{400..449}
TestDSC3 = outf2?x -> STOP
          [| diff( {|outf2|}, {outf2.77.444} ) |] STOP -- takes very long with FDR  and ProB
          -- 127 seconds on Powerbook G4 12" with FDR for deadlock check for {0..99}.{0..999}
-- for ProB: we probably need to go to a binary-tree set representation


TestDSC5 = outf?x -> out!99 -> STOP [| diff( {outf.2,outf.8,outf.3}, {outf.8} ) |] outf!2 -> STOP 
TestDSC6 = outf?x -> out!99 -> STOP [| {outf.2,outf.8,outf.3}|] outf!2 -> STOP 

-- Find out whether SetCompr need to be included in lambda lifting
-- Answer: yes (as function appl. waits for groundness !)
channel in:Int
TestVar1(p) = TestVar2({x*x|x<-p })
TestVar2(sc) = in?x:sc -> out!x -> TestVar2(sc)
TestVar = TestVar1({1,3,5})

SC(p) = {x*x|x<-p }
TestVar1b(p) = TestVar2(SC(p))
TestVarb = TestVar1b({1,3,5})

-- Trace Check Generated by ProB:
PROB_TEST_TRACE = out.5 -> out.3 -> out.20 -> out.12 -> out.5 -> out.3 -> out.1 -> out.4 -> out.20 -> out.12 -> out.10 -> out.9 -> out.7 -> out.6 -> out.5 -> out.4 -> out.3 -> out.2 -> out.2 -> out.4 -> out.12 -> SKIP ; STOP

assert MAIN [T= PROB_TEST_TRACE